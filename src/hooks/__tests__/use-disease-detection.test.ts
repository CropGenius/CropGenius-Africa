/**\n * ðŸŒ¾ INFINITY-LEVEL Disease Detection Hook Tests\n * \n * PRODUCTION-READY tests for the disease detection hook\n * ensuring reliability for 100 million African farmers! ðŸš€\n */\n\nimport { renderHook, act, waitFor } from '@testing-library/react';\nimport { vi, describe, it, expect, beforeEach, afterEach } from 'vitest';\nimport { useDiseaseDetection } from '../use-disease-detection';\nimport { supabase } from '@/integrations/supabase/client';\nimport { useAuthContext } from '@/providers/AuthProvider';\nimport { useSmartLocation } from '../useSmartLocation';\nimport { useToast } from '@/components/ui/use-toast';\n\n// Mock dependencies\nvi.mock('@/integrations/supabase/client', () => ({\n  supabase: {\n    from: vi.fn(),\n    storage: {\n      from: vi.fn(),\n    },\n  },\n}));\n\nvi.mock('@/providers/AuthProvider', () => ({\n  useAuthContext: vi.fn(),\n}));\n\nvi.mock('../useSmartLocation', () => ({\n  useSmartLocation: vi.fn(),\n}));\n\nvi.mock('@/components/ui/use-toast', () => ({\n  useToast: vi.fn(),\n}));\n\nvi.mock('@/api/cropDiseaseApi', () => ({\n  handleCropDiseaseDetectionUpload: vi.fn(),\n}));\n\n// Mock data\nconst mockUser = {\n  id: 'user-123',\n  email: 'farmer@example.com',\n};\n\nconst mockLocation = {\n  lat: -1.2921,\n  lng: 36.8219,\n  country: 'Kenya',\n  region: 'Nairobi',\n};\n\nconst mockDetectionResult = {\n  disease_name: 'Northern Leaf Blight',\n  scientific_name: 'Exserohilum turcicum',\n  confidence: 92,\n  severity: 'high' as const,\n  affected_area_percentage: 25,\n  crop_type: 'Maize',\n  symptoms: ['Long elliptical lesions on leaves'],\n  immediate_actions: ['Apply fungicide', 'Remove infected leaves'],\n  preventive_measures: ['Plant resistant varieties'],\n  organic_solutions: ['Neem oil application'],\n  inorganic_solutions: ['Systemic fungicide'],\n  recommended_products: ['Ridomil Gold'],\n  economic_impact: {\n    yield_loss_percentage: 25,\n    revenue_loss_usd: 150,\n    treatment_cost_usd: 30,\n  },\n  local_suppliers: [],\n  recovery_timeline: '7-14 days',\n  spread_risk: 'medium' as const,\n  source_api: 'plantnet' as const,\n  timestamp: new Date().toISOString(),\n};\n\nconst mockDetectionHistory = [\n  {\n    id: 'detection-1',\n    created_at: '2023-07-15T10:30:00Z',\n    crop_type: 'Maize',\n    disease_name: 'Northern Leaf Blight',\n    confidence: 92,\n    image_url: 'https://example.com/image1.jpg',\n    treatment_recommendations: 'Apply fungicide and remove infected leaves.',\n    field_id: 'field-1',\n    field_name: 'North Field',\n    location: { lat: -1.2921, lng: 36.8219 },\n    status: 'confirmed' as const,\n    user_id: 'user-123',\n    result_data: mockDetectionResult,\n  },\n];\n\nconst mockToast = vi.fn();\n\ndescribe('useDiseaseDetection Hook - INFINITY GOD MODE Tests', () => {\n  beforeEach(() => {\n    vi.clearAllMocks();\n    \n    // Setup mocks\n    (useAuthContext as any).mockReturnValue({ user: mockUser });\n    (useSmartLocation as any).mockReturnValue({ location: mockLocation });\n    (useToast as any).mockReturnValue({ toast: mockToast });\n    \n    // Setup Supabase mocks\n    const mockSelect = vi.fn().mockReturnThis();\n    const mockEq = vi.fn().mockReturnThis();\n    const mockOrder = vi.fn().mockReturnThis();\n    const mockLimit = vi.fn().mockResolvedValue({ data: mockDetectionHistory, error: null });\n    \n    (supabase.from as any).mockReturnValue({\n      select: mockSelect,\n      eq: mockEq,\n      order: mockOrder,\n      limit: mockLimit,\n      insert: vi.fn().mockResolvedValue({ error: null }),\n      delete: vi.fn().mockReturnThis(),\n    });\n    \n    mockSelect.mockReturnValue({\n      eq: mockEq,\n      order: mockOrder,\n      limit: mockLimit,\n    });\n    \n    mockEq.mockReturnValue({\n      order: mockOrder,\n      limit: mockLimit,\n    });\n    \n    mockOrder.mockReturnValue({\n      limit: mockLimit,\n    });\n  });\n\n  afterEach(() => {\n    vi.restoreAllMocks();\n  });\n\n  describe('ðŸŒŸ Hook Initialization', () => {\n    it('should initialize with correct default values', () => {\n      const { result } = renderHook(() => useDiseaseDetection());\n\n      expect(result.current.isDetecting).toBe(false);\n      expect(result.current.detectionResult).toBeNull();\n      expect(result.current.detectionHistory).toEqual([]);\n      expect(result.current.error).toBeNull();\n      expect(typeof result.current.detectDisease).toBe('function');\n      expect(typeof result.current.clearError).toBe('function');\n      expect(typeof result.current.clearResult).toBe('function');\n      expect(typeof result.current.saveToHistory).toBe('function');\n      expect(typeof result.current.deleteDetection).toBe('function');\n      expect(typeof result.current.exportDetectionHistory).toBe('function');\n      expect(typeof result.current.refreshHistory).toBe('function');\n    });\n\n    it('should fetch detection history on mount when user is available', async () => {\n      renderHook(() => useDiseaseDetection());\n\n      await waitFor(() => {\n        expect(supabase.from).toHaveBeenCalledWith('crop_disease_detections');\n      });\n    });\n\n    it('should not fetch history when user is not available', () => {\n      (useAuthContext as any).mockReturnValue({ user: null });\n      \n      renderHook(() => useDiseaseDetection());\n\n      expect(supabase.from).not.toHaveBeenCalled();\n    });\n  });\n\n  describe('ðŸ” Disease Detection', () => {\n    it('should detect disease successfully', async () => {\n      const { handleCropDiseaseDetectionUpload } = await import('@/api/cropDiseaseApi');\n      (handleCropDiseaseDetectionUpload as any).mockResolvedValue({\n        success: true,\n        data: mockDetectionResult,\n      });\n\n      const { result } = renderHook(() => useDiseaseDetection());\n      const mockFile = new File(['test'], 'test.jpg', { type: 'image/jpeg' });\n\n      await act(async () => {\n        await result.current.detectDisease(mockFile, 'maize');\n      });\n\n      expect(result.current.detectionResult).toEqual(mockDetectionResult);\n      expect(result.current.isDetecting).toBe(false);\n      expect(result.current.error).toBeNull();\n      expect(mockToast).toHaveBeenCalledWith({\n        title: \"Disease Detection Complete!\",\n        description: expect.stringContaining('Northern Leaf Blight'),\n      });\n    });\n\n    it('should handle detection errors gracefully', async () => {\n      const { handleCropDiseaseDetectionUpload } = await import('@/api/cropDiseaseApi');\n      (handleCropDiseaseDetectionUpload as any).mockResolvedValue({\n        success: false,\n        error: 'API error occurred',\n      });\n\n      const { result } = renderHook(() => useDiseaseDetection());\n      const mockFile = new File(['test'], 'test.jpg', { type: 'image/jpeg' });\n\n      await act(async () => {\n        await result.current.detectDisease(mockFile, 'maize');\n      });\n\n      expect(result.current.detectionResult).toBeNull();\n      expect(result.current.error).toBe('API error occurred');\n      expect(mockToast).toHaveBeenCalledWith({\n        title: \"Detection Failed\",\n        description: 'API error occurred',\n        variant: \"destructive\",\n      });\n    });\n\n    it('should validate user authentication', async () => {\n      (useAuthContext as any).mockReturnValue({ user: null });\n      \n      const { result } = renderHook(() => useDiseaseDetection());\n      const mockFile = new File(['test'], 'test.jpg', { type: 'image/jpeg' });\n\n      await act(async () => {\n        await result.current.detectDisease(mockFile, 'maize');\n      });\n\n      expect(result.current.error).toBe('You must be logged in to detect diseases');\n    });\n\n    it('should validate location availability', async () => {\n      (useSmartLocation as any).mockReturnValue({ location: null });\n      \n      const { result } = renderHook(() => useDiseaseDetection());\n      const mockFile = new File(['test'], 'test.jpg', { type: 'image/jpeg' });\n\n      await act(async () => {\n        await result.current.detectDisease(mockFile, 'maize');\n      });\n\n      expect(result.current.error).toBe('Location access is required for accurate disease detection');\n    });\n  });\n\n  describe('ðŸ“š History Management', () => {\n    it('should delete detection successfully', async () => {\n      const mockDelete = vi.fn().mockResolvedValue({ error: null });\n      (supabase.from as any).mockReturnValue({\n        delete: () => ({\n          eq: () => ({\n            eq: mockDelete,\n          }),\n        }),\n        select: vi.fn().mockReturnThis(),\n        eq: vi.fn().mockReturnThis(),\n        order: vi.fn().mockReturnThis(),\n        limit: vi.fn().mockResolvedValue({ data: [], error: null }),\n      });\n\n      const { result } = renderHook(() => useDiseaseDetection());\n\n      await act(async () => {\n        const response = await result.current.deleteDetection('detection-1');\n        expect(response.success).toBe(true);\n      });\n\n      expect(mockDelete).toHaveBeenCalled();\n    });\n\n    it('should handle delete errors', async () => {\n      const mockDelete = vi.fn().mockResolvedValue({ error: new Error('Delete failed') });\n      (supabase.from as any).mockReturnValue({\n        delete: () => ({\n          eq: () => ({\n            eq: mockDelete,\n          }),\n        }),\n      });\n\n      const { result } = renderHook(() => useDiseaseDetection());\n\n      await act(async () => {\n        const response = await result.current.deleteDetection('detection-1');\n        expect(response.success).toBe(false);\n        expect(response.error).toBe('Delete failed');\n      });\n    });\n\n    it('should export detection history as CSV', async () => {\n      // Mock URL.createObjectURL and document methods\n      global.URL.createObjectURL = vi.fn(() => 'blob:mock-url');\n      const mockClick = vi.fn();\n      const mockAppendChild = vi.fn();\n      const mockRemoveChild = vi.fn();\n      const mockCreateElement = vi.fn(() => ({\n        setAttribute: vi.fn(),\n        click: mockClick,\n        style: { visibility: '' },\n      }));\n      \n      Object.defineProperty(document, 'createElement', {\n        value: mockCreateElement,\n      });\n      Object.defineProperty(document.body, 'appendChild', {\n        value: mockAppendChild,\n      });\n      Object.defineProperty(document.body, 'removeChild', {\n        value: mockRemoveChild,\n      });\n\n      const { result } = renderHook(() => useDiseaseDetection());\n      \n      // Set some history data\n      await waitFor(() => {\n        expect(result.current.detectionHistory.length).toBeGreaterThan(0);\n      });\n\n      await act(async () => {\n        const response = await result.current.exportDetectionHistory();\n        expect(response.success).toBe(true);\n      });\n\n      expect(mockCreateElement).toHaveBeenCalledWith('a');\n      expect(mockClick).toHaveBeenCalled();\n    });\n\n    it('should handle empty history export', async () => {\n      // Mock empty history\n      (supabase.from as any).mockReturnValue({\n        select: vi.fn().mockReturnThis(),\n        eq: vi.fn().mockReturnThis(),\n        order: vi.fn().mockReturnThis(),\n        limit: vi.fn().mockResolvedValue({ data: [], error: null }),\n      });\n\n      const { result } = renderHook(() => useDiseaseDetection());\n\n      await act(async () => {\n        const response = await result.current.exportDetectionHistory();\n        expect(response.success).toBe(false);\n        expect(response.error).toBe('No detection history to export');\n      });\n    });\n  });\n\n  describe('ðŸ”„ Utility Functions', () => {\n    it('should clear error', () => {\n      const { result } = renderHook(() => useDiseaseDetection());\n\n      act(() => {\n        result.current.clearError();\n      });\n\n      expect(result.current.error).toBeNull();\n    });\n\n    it('should clear result', () => {\n      const { result } = renderHook(() => useDiseaseDetection());\n\n      act(() => {\n        result.current.clearResult();\n      });\n\n      expect(result.current.detectionResult).toBeNull();\n    });\n\n    it('should refresh history', async () => {\n      const { result } = renderHook(() => useDiseaseDetection());\n\n      await act(async () => {\n        await result.current.refreshHistory();\n      });\n\n      expect(supabase.from).toHaveBeenCalledWith('crop_disease_detections');\n    });\n  });\n\n  describe('ðŸ’¾ Save to History', () => {\n    it('should save detection to history with image upload', async () => {\n      const mockUpload = vi.fn().mockResolvedValue({\n        data: { path: 'user-123/image.jpg' },\n        error: null,\n      });\n      const mockGetPublicUrl = vi.fn().mockReturnValue({\n        data: { publicUrl: 'https://example.com/image.jpg' },\n      });\n      const mockInsert = vi.fn().mockResolvedValue({ error: null });\n\n      (supabase.storage as any).from.mockReturnValue({\n        upload: mockUpload,\n        getPublicUrl: mockGetPublicUrl,\n      });\n      \n      (supabase.from as any).mockReturnValue({\n        insert: mockInsert,\n        select: vi.fn().mockReturnThis(),\n        eq: vi.fn().mockReturnThis(),\n        order: vi.fn().mockReturnThis(),\n        limit: vi.fn().mockResolvedValue({ data: [], error: null }),\n      });\n\n      const { result } = renderHook(() => useDiseaseDetection());\n      const mockFile = new File(['test'], 'test.jpg', { type: 'image/jpeg' });\n\n      await act(async () => {\n        await result.current.saveToHistory(mockDetectionResult, mockFile);\n      });\n\n      expect(mockUpload).toHaveBeenCalled();\n      expect(mockInsert).toHaveBeenCalledWith(expect.objectContaining({\n        user_id: mockUser.id,\n        disease_name: mockDetectionResult.disease_name,\n        confidence: mockDetectionResult.confidence,\n        image_url: 'https://example.com/image.jpg',\n      }));\n    });\n\n    it('should save detection without image', async () => {\n      const mockInsert = vi.fn().mockResolvedValue({ error: null });\n      \n      (supabase.from as any).mockReturnValue({\n        insert: mockInsert,\n        select: vi.fn().mockReturnThis(),\n        eq: vi.fn().mockReturnThis(),\n        order: vi.fn().mockReturnThis(),\n        limit: vi.fn().mockResolvedValue({ data: [], error: null }),\n      });\n\n      const { result } = renderHook(() => useDiseaseDetection());\n\n      await act(async () => {\n        await result.current.saveToHistory(mockDetectionResult);\n      });\n\n      expect(mockInsert).toHaveBeenCalledWith(expect.objectContaining({\n        user_id: mockUser.id,\n        disease_name: mockDetectionResult.disease_name,\n        confidence: mockDetectionResult.confidence,\n        image_url: undefined,\n      }));\n    });\n  });\n});"