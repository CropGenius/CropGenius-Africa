import React from 'react';\nimport { QueryClient, QueryClientProvider } from '@tanstack/react-query';\nimport { BrowserRouter, MemoryRouter } from 'react-router-dom';\nimport { render, RenderOptions, RenderResult } from '@testing-library/react';\nimport { vi } from 'vitest';\nimport { AuthProvider } from '@/providers/AuthProvider';\nimport { GrowthEngineProvider } from '@/providers/GrowthEngineProvider';\nimport { Toaster } from '@/components/ui/sonner';\nimport { mockUserData } from './mocks/data/userData';\n\n// Enhanced test utilities for INFINITY-LEVEL testing ðŸš€\n\ninterface CustomRenderOptions extends Omit<RenderOptions, 'wrapper'> {\n  // Router options\n  initialEntries?: string[];\n  initialIndex?: number;\n  useMemoryRouter?: boolean;\n  \n  // Auth options\n  authenticated?: boolean;\n  user?: typeof mockUserData.authenticatedUser;\n  userProfile?: typeof mockUserData.userProfile;\n  \n  // Query client options\n  queryClient?: QueryClient;\n  \n  // Provider options\n  withAuthProvider?: boolean;\n  withGrowthEngine?: boolean;\n  withToaster?: boolean;\n  \n  // Mock options\n  mockSupabase?: boolean;\n  mockToast?: boolean;\n}\n\n// Create a comprehensive test wrapper with all providers\nconst createTestWrapper = (options: CustomRenderOptions = {}) => {\n  const {\n    initialEntries = ['/'],\n    initialIndex = 0,\n    useMemoryRouter = false,\n    authenticated = false,\n    user = mockUserData.authenticatedUser,\n    userProfile = mockUserData.userProfile,\n    queryClient,\n    withAuthProvider = true,\n    withGrowthEngine = true,\n    withToaster = true,\n  } = options;\n\n  const testQueryClient = queryClient || new QueryClient({\n    defaultOptions: {\n      queries: {\n        retry: false,\n        cacheTime: 0,\n        staleTime: 0,\n        refetchOnWindowFocus: false,\n        refetchOnMount: false,\n        refetchOnReconnect: false,\n      },\n      mutations: {\n        retry: false,\n      },\n    },\n    logger: {\n      log: () => {},\n      warn: () => {},\n      error: () => {},\n    },\n  });\n\n  const RouterComponent = useMemoryRouter ? MemoryRouter : BrowserRouter;\n  const routerProps = useMemoryRouter ? { initialEntries, initialIndex } : {};\n\n  return ({ children }: { children: React.ReactNode }) => {\n    let wrappedChildren = (\n      <QueryClientProvider client={testQueryClient}>\n        <RouterComponent {...routerProps}>\n          {children}\n        </RouterComponent>\n      </QueryClientProvider>\n    );\n\n    if (withAuthProvider) {\n      // Mock auth context value\n      const mockAuthValue = {\n        user: authenticated ? user : null,\n        profile: authenticated ? userProfile : null,\n        loading: false,\n        signIn: vi.fn().mockResolvedValue({ error: null }),\n        signUp: vi.fn().mockResolvedValue({ error: null }),\n        signOut: vi.fn().mockResolvedValue({ error: null }),\n        updateProfile: vi.fn().mockResolvedValue({ error: null }),\n        isAuthenticated: authenticated,\n      };\n\n      wrappedChildren = (\n        <AuthProvider value={mockAuthValue}>\n          {wrappedChildren}\n        </AuthProvider>\n      );\n    }\n\n    if (withGrowthEngine) {\n      const mockGrowthValue = {\n        credits: userProfile?.credits_balance || 50,\n        totalCreditsEarned: userProfile?.total_credits_earned || 100,\n        totalCreditsSpent: userProfile?.total_credits_spent || 50,\n        subscriptionTier: userProfile?.subscription_tier || 'free',\n        earnCredits: vi.fn(),\n        spendCredits: vi.fn(),\n        checkCredits: vi.fn().mockReturnValue(true),\n        refreshCredits: vi.fn(),\n      };\n\n      wrappedChildren = (\n        <GrowthEngineProvider value={mockGrowthValue}>\n          {wrappedChildren}\n        </GrowthEngineProvider>\n      );\n    }\n\n    if (withToaster) {\n      wrappedChildren = (\n        <>\n          {wrappedChildren}\n          <Toaster />\n        </>\n      );\n    }\n\n    return wrappedChildren;\n  };\n};\n\n// Enhanced render function\nconst customRender = (\n  ui: React.ReactElement,\n  options: CustomRenderOptions = {}\n): RenderResult => {\n  const { ...renderOptions } = options;\n  const Wrapper = createTestWrapper(options);\n  \n  return render(ui, { wrapper: Wrapper, ...renderOptions });\n};\n\n// Utility functions for common test scenarios\n\n// Render with authenticated user\nexport const renderWithAuth = (\n  ui: React.ReactElement,\n  options: CustomRenderOptions = {}\n) => {\n  return customRender(ui, {\n    authenticated: true,\n    ...options,\n  });\n};\n\n// Render with unauthenticated user\nexport const renderWithoutAuth = (\n  ui: React.ReactElement,\n  options: CustomRenderOptions = {}\n) => {\n  return customRender(ui, {\n    authenticated: false,\n    ...options,\n  });\n};\n\n// Render with specific route\nexport const renderWithRoute = (\n  ui: React.ReactElement,\n  route: string,\n  options: CustomRenderOptions = {}\n) => {\n  return customRender(ui, {\n    useMemoryRouter: true,\n    initialEntries: [route],\n    ...options,\n  });\n};\n\n// Render with custom query client\nexport const renderWithQueryClient = (\n  ui: React.ReactElement,\n  queryClient: QueryClient,\n  options: CustomRenderOptions = {}\n) => {\n  return customRender(ui, {\n    queryClient,\n    ...options,\n  });\n};\n\n// Create a mock query client with predefined data\nexport const createMockQueryClient = (initialData: Record<string, any> = {}) => {\n  const queryClient = new QueryClient({\n    defaultOptions: {\n      queries: {\n        retry: false,\n        cacheTime: 0,\n        staleTime: 0,\n      },\n    },\n  });\n\n  // Pre-populate with mock data\n  Object.entries(initialData).forEach(([key, data]) => {\n    queryClient.setQueryData([key], data);\n  });\n\n  return queryClient;\n};\n\n// Wait for async operations to complete\nexport const waitForLoadingToFinish = async () => {\n  const { waitFor } = await import('@testing-library/react');\n  await waitFor(() => {\n    expect(document.querySelector('[data-testid=\"loading\"]')).not.toBeInTheDocument();\n  }, { timeout: 5000 });\n};\n\n// Mock user interactions with enhanced functionality\nexport const mockUserInteraction = {\n  click: async (element: HTMLElement) => {\n    const { fireEvent } = await import('@testing-library/react');\n    fireEvent.click(element);\n  },\n  \n  type: async (element: HTMLElement, text: string) => {\n    const { fireEvent } = await import('@testing-library/react');\n    fireEvent.change(element, { target: { value: text } });\n  },\n  \n  submit: async (form: HTMLElement) => {\n    const { fireEvent } = await import('@testing-library/react');\n    fireEvent.submit(form);\n  },\n  \n  selectOption: async (select: HTMLElement, value: string) => {\n    const { fireEvent } = await import('@testing-library/react');\n    fireEvent.change(select, { target: { value } });\n  },\n  \n  uploadFile: async (input: HTMLElement, file: File) => {\n    const { fireEvent } = await import('@testing-library/react');\n    fireEvent.change(input, { target: { files: [file] } });\n  },\n};\n\n// Test data factories\nexport const createTestFile = (name = 'test.jpg', type = 'image/jpeg') => {\n  return new File(['test content'], name, { type });\n};\n\nexport const createTestImage = () => {\n  return createTestFile('crop-image.jpg', 'image/jpeg');\n};\n\n// Assertion helpers\nexport const expectElementToBeVisible = (element: HTMLElement) => {\n  expect(element).toBeInTheDocument();\n  expect(element).toBeVisible();\n};\n\nexport const expectElementToHaveText = (element: HTMLElement, text: string) => {\n  expect(element).toBeInTheDocument();\n  expect(element).toHaveTextContent(text);\n};\n\nexport const expectFormToBeValid = (form: HTMLElement) => {\n  expect(form).toBeInTheDocument();\n  expect(form.checkValidity()).toBe(true);\n};\n\n// Performance testing helpers\nexport const measureRenderTime = async (renderFn: () => void) => {\n  const start = performance.now();\n  renderFn();\n  const end = performance.now();\n  return end - start;\n};\n\n// Accessibility testing helpers\nexport const expectElementToBeAccessible = async (element: HTMLElement) => {\n  const { axe, toHaveNoViolations } = await import('jest-axe');\n  expect.extend(toHaveNoViolations);\n  \n  const results = await axe(element);\n  expect(results).toHaveNoViolations();\n};\n\n// Mock network conditions\nexport const mockSlowNetwork = () => {\n  // Simulate slow network by adding delays to fetch\n  const originalFetch = global.fetch;\n  global.fetch = vi.fn().mockImplementation(async (...args) => {\n    await new Promise(resolve => setTimeout(resolve, 2000));\n    return originalFetch(...args);\n  });\n};\n\nexport const mockOfflineNetwork = () => {\n  // Simulate offline network\n  global.fetch = vi.fn().mockRejectedValue(new Error('Network error'));\n};\n\nexport const restoreNetwork = () => {\n  // Restore original fetch\n  vi.restoreAllMocks();\n};\n\n// Re-export everything from testing-library\nexport * from '@testing-library/react';\nexport { userEvent } from '@testing-library/user-event';\n\n// Override render method\nexport { customRender as render };